<div
  id="astronaut"
  class="pointer-events-none fixed z-30 hidden opacity-0 dark:opacity-100"
  aria-hidden="true"
>
  <div class="astronaut-glow"></div>
  <img
    src="/astronaut.svg"
    alt=""
    class="astronaut-img h-[210px] w-[210px]"
  />
</div>

<style>
  #astronaut {
    will-change: transform;
  }

  .astronaut-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300px;
    height: 300px;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, rgba(5, 150, 105, 0.15) 0%, transparent 70%);
    filter: blur(20px);
    pointer-events: none;
    z-index: -1;
    will-change: opacity, transform;
    transition: opacity 0.5s ease, transform 0.5s ease;
  }

  #astronaut.scrolling .astronaut-glow {
    opacity: 0.25;
    transform: translate(-50%, -50%) scale(1.1);
  }

  .astronaut-img {
    position: relative;
    filter: drop-shadow(0 0 10px rgba(5, 150, 105, 0.25));
    will-change: transform;
    transition: filter 0.5s ease;
  }

  #astronaut.hovered .astronaut-img {
    filter: drop-shadow(0 0 30px rgba(5, 150, 105, 0.35));
  }
</style>

<script>
  const astronaut = document.getElementById("astronaut");
  const img = astronaut?.querySelector<HTMLElement>(".astronaut-img");
  const glow = astronaut?.querySelector<HTMLElement>(".astronaut-glow");

  if (astronaut && img && glow) {
    // ── Constants ──
    const BASE_SIZE = 210;
    const MIN_SIZE = 140;
    const MIN_VIEWPORT = 1280;
    const SCROLL_THRESHOLD = 100;
    const MAX_TILT = 12;
    const HOVER_RADIUS = 140;
    const MOUSE_ATTRACT = 0.04;
    const HOVER_SCALE = 1.2;
    const HOVER_SPEED = 0.2; // hero orbit speed when hovered

    // ── Smoothing speeds (per second) ──
    const SMOOTH_POS = 4.5;
    const SMOOTH_POS_FAST = 8.0; // during dash
    const SMOOTH_ROT = 3.5;
    const SMOOTH_SCALE = 8.0;

    // ── Dynamic sizing ──
    let SIZE = BASE_SIZE;
    let isVisible = false;

    function getContentMarginLeft(): number {
      const el = document.querySelector("#hero .mx-auto") ||
                 document.querySelector(".mx-auto.max-w-5xl");
      if (!el) return window.innerWidth * 0.1;
      return el.getBoundingClientRect().left;
    }

    function updateVisibility() {
      const vw = window.innerWidth;
      if (vw < MIN_VIEWPORT) {
        if (isVisible) { astronaut.style.display = "none"; isVisible = false; }
        return;
      }
      const margin = getContentMarginLeft();
      const space = margin - 30;
      if (space < MIN_SIZE) {
        if (isVisible) { astronaut.style.display = "none"; isVisible = false; }
        return;
      }
      SIZE = Math.min(BASE_SIZE, Math.max(MIN_SIZE, space - 20));
      img.style.width = SIZE + "px";
      img.style.height = SIZE + "px";
      if (!isVisible) { astronaut.style.display = "block"; isVisible = true; }
    }

    // ── State ──
    let currentX = 0;
    let currentY = 0;
    let currentRot = 0;
    let currentScale = 1;
    let lastTime = performance.now();
    let lastScrollY = window.scrollY;
    let scrollVelocity = 0;
    let smoothScrollVel = 0;
    let isDashing = false;
    let dashTimer: ReturnType<typeof setTimeout> | null = null;

    // Mouse
    let mouseX = -9999;
    let mouseY = -9999;
    let isHovered = false;

    // Card hover
    let cardTarget: { x: number; y: number } | null = null;

    // Hero virtual time (slows when hovered)
    let heroTime = Math.random() * 100000;

    // ── Helpers ──
    function damp(speed: number, dt: number): number {
      return 1 - Math.exp(-speed * dt);
    }

    function clamp(v: number, min: number, max: number): number {
      return Math.max(min, Math.min(max, v));
    }

    // ── Hero position: simple Lissajous curve ──
    function getHeroPos(): { x: number; y: number; rot: number } {
      const NAV_HEIGHT = 80;
      const content = document.querySelector("#hero .mx-auto.max-w-5xl") ||
                       document.querySelector("#hero");
      if (!content) return { x: 100, y: 200, rot: 0 };

      const rect = content.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;

      // Ellipse wider & taller than the content
      const radiusX = rect.width / 2 + SIZE + 40;
      const radiusY = rect.height / 2 + SIZE + 20;

      const t = heroTime * 0.00025; // slow, relaxed orbit
      const rawX = cx + Math.cos(t) * radiusX - SIZE / 2;
      const rawY = cy + Math.sin(t) * radiusY - SIZE / 2;

      // Clamp to viewport (don't go behind nav or off-screen)
      const x = clamp(rawX, 10, window.innerWidth - SIZE - 10);
      const y = clamp(rawY, NAV_HEIGHT + 10, window.innerHeight - SIZE - 10);

      // Tilt into turns
      const rot = Math.cos(t) * -10;

      return { x, y, rot };
    }

    // ── Scroll position ──
    function getScrollBaseX(): number {
      const margin = getContentMarginLeft();
      return Math.max(10, (margin - SIZE) / 2);
    }

    function getScrollTargetY(): number {
      const scrollY = window.scrollY;
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      if (maxScroll <= 0) return window.innerHeight * 0.2;
      const ratio = scrollY / maxScroll;
      return window.innerHeight * (0.1 + ratio * 0.7);
    }

    // ── Mouse hover ──
    function applyMouseHover(x: number, y: number): { x: number; y: number } {
      const cx = x + SIZE / 2;
      const cy = y + SIZE / 2;
      const dx = mouseX - cx;
      const dy = mouseY - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);

      const wasHovered = isHovered;
      isHovered = dist < HOVER_RADIUS;

      if (isHovered !== wasHovered) {
        if (isHovered) {
          astronaut.classList.add("hovered");
          glow.style.opacity = "0.25";
          glow.style.transform = "translate(-50%, -50%) scale(1.1)";
        } else {
          astronaut.classList.remove("hovered");
          glow.style.opacity = "";
          glow.style.transform = "";
        }
      }

      if (isHovered) {
        return {
          x: x + (mouseX - cx) * MOUSE_ATTRACT,
          y: y + (mouseY - cy) * MOUSE_ATTRACT,
        };
      }
      return { x, y };
    }

    // ── Main tick ──
    function tick(now: number) {
      if (!isVisible) { requestAnimationFrame(tick); return; }

      const dt = Math.min((now - lastTime) / 1000, 0.1);
      lastTime = now;

      // Scroll tracking
      const newScrollY = window.scrollY;
      scrollVelocity = newScrollY - lastScrollY;
      smoothScrollVel += (scrollVelocity - smoothScrollVel) * damp(8, dt);
      lastScrollY = newScrollY;

      // Dash detection: boost smoothing speed briefly when crossing threshold
      if (!isDashing && newScrollY >= SCROLL_THRESHOLD && currentY < window.innerHeight * 0.3) {
        isDashing = true;
        astronaut.classList.add("scrolling");
        if (dashTimer) clearTimeout(dashTimer);
        dashTimer = setTimeout(() => {
          isDashing = false;
          astronaut.classList.remove("scrolling");
        }, 500);
      }

      // ── 1. Determine target ──
      let targetX: number;
      let targetY: number;
      let targetRot: number;

      const inHero = newScrollY < SCROLL_THRESHOLD;

      if (inHero) {
        // Advance hero time (slower when hovered)
        heroTime += dt * 1000 * (isHovered ? HOVER_SPEED : 1);
        const pos = getHeroPos();
        targetX = pos.x;
        targetY = pos.y;
        targetRot = pos.rot;
      } else {
        // Scroll mode: left margin, follow scroll, idle float built-in
        const idleFloat = Math.sin(now * 0.002) * 6;
        targetX = getScrollBaseX();
        targetY = getScrollTargetY() + idleFloat;
        targetRot = clamp(smoothScrollVel * 1.2, -MAX_TILT, MAX_TILT);

        // Scrolling glow
        if (Math.abs(scrollVelocity) > 0.5) {
          astronaut.classList.add("scrolling");
          if (dashTimer) clearTimeout(dashTimer);
          dashTimer = setTimeout(() => {
            astronaut.classList.remove("scrolling");
          }, 800);
        }
      }

      // ── 2. Card/section hover override ──
      if (cardTarget) {
        targetX = cardTarget.x;
        targetY = cardTarget.y;
        targetRot = 0;
        // Tilt toward target
        const dx = cardTarget.x - currentX;
        const dy = cardTarget.y - currentY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 5) {
          targetRot = clamp(Math.atan2(dy, dx) * (180 / Math.PI) * 0.12, -MAX_TILT, MAX_TILT);
        }
      }

      // ── 3. Mouse attraction ──
      const m = applyMouseHover(targetX, targetY);
      targetX = m.x;
      targetY = m.y;

      // ── 4. Smooth everything ──
      const speed = isDashing ? SMOOTH_POS_FAST : SMOOTH_POS;
      currentX += (targetX - currentX) * damp(speed, dt);
      currentY += (targetY - currentY) * damp(speed, dt);
      currentRot += (targetRot - currentRot) * damp(SMOOTH_ROT, dt);

      // Scale: hover > fast scroll > normal
      const absVel = Math.abs(smoothScrollVel);
      const targetScale = isHovered ? HOVER_SCALE
        : isDashing ? 1.15
        : absVel > 15 ? 1.15
        : 1;
      currentScale += (targetScale - currentScale) * damp(SMOOTH_SCALE, dt);

      // ── 5. Apply ──
      astronaut.style.transform = `translate3d(${currentX.toFixed(1)}px, ${currentY.toFixed(1)}px, 0)`;
      img.style.transform = `rotate(${currentRot.toFixed(1)}deg) scale(${currentScale.toFixed(3)})`;

      // ── 6. Timeline dots ──
      updateTimelineDots();

      requestAnimationFrame(tick);
    }

    // ── Timeline dots ──
    const timelineEntries = document.querySelectorAll<HTMLElement>(".timeline-entry");
    const SECTION_EARLY = 20;
    let activeDot: HTMLElement | null = null;
    let cardHoveredDot: HTMLElement | null = null;

    function updateTimelineDots() {
      if (!isVisible || window.scrollY < SCROLL_THRESHOLD) {
        if (activeDot) { activeDot.classList.remove("astronaut-near"); activeDot = null; }
        return;
      }

      let bestDot: HTMLElement | null = cardHoveredDot;

      if (!bestDot) {
        const astroCenterY = currentY + SIZE / 2;
        let bestDist = Infinity;
        timelineEntries.forEach((entry) => {
          const rect = entry.getBoundingClientRect();
          const top = rect.top - SECTION_EARLY;
          const bottom = rect.bottom + SECTION_EARLY;
          let dist: number;
          if (astroCenterY >= top && astroCenterY <= bottom) {
            dist = 0;
          } else {
            dist = Math.min(Math.abs(astroCenterY - top), Math.abs(astroCenterY - bottom));
          }
          if (dist < bestDist && dist === 0) {
            bestDist = dist;
            bestDot = entry.querySelector<HTMLElement>(".timeline-dot");
          }
        });
      }

      if (bestDot !== activeDot) {
        if (activeDot) activeDot.classList.remove("astronaut-near");
        if (bestDot) bestDot.classList.add("astronaut-near");
        activeDot = bestDot;
      }
    }

    // ── Initialize ──
    updateVisibility();
    if (isVisible) {
      if (window.scrollY < SCROLL_THRESHOLD) {
        const pos = getHeroPos();
        currentX = pos.x;
        currentY = pos.y;
        currentRot = pos.rot;
      } else {
        currentX = getScrollBaseX();
        currentY = getScrollTargetY();
      }
    }
    requestAnimationFrame(tick);

    // ── Event listeners ──
    window.addEventListener("resize", updateVisibility);

    document.addEventListener("mousemove", (e) => { mouseX = e.clientX; mouseY = e.clientY; });
    document.addEventListener("mouseleave", () => { mouseX = -9999; mouseY = -9999; });

    // Nav click boost
    document.querySelectorAll('a[href^="#"]').forEach((link) => {
      link.addEventListener("click", () => {
        isDashing = true;
        if (dashTimer) clearTimeout(dashTimer);
        dashTimer = setTimeout(() => { isDashing = false; }, 600);
      });
    });

    // ── Card/section hover ──
    function setCardTarget(el: HTMLElement) {
      if (window.scrollY < SCROLL_THRESHOLD) return;
      const rect = el.getBoundingClientRect();
      cardTarget = {
        x: Math.max(10, rect.left - SIZE - 20),
        y: rect.top + rect.height / 2 - SIZE / 2,
      };
      if (cardTarget.x < 10) {
        cardTarget.x = rect.left + 20;
        cardTarget.y = Math.max(10, rect.top - SIZE - 15);
      }
    }

    // Section cards
    document.querySelectorAll<HTMLElement>(".section-card:not(.section-card--static)").forEach((card) => {
      card.addEventListener("mouseenter", () => {
        setCardTarget(card);
        const entry = card.closest(".timeline-entry");
        cardHoveredDot = entry?.querySelector<HTMLElement>(".timeline-dot") || null;
      });
      card.addEventListener("mouseleave", () => { cardTarget = null; cardHoveredDot = null; });
    });

    // Skills + Contact: follow cursor Y
    ["skills", "contact"].forEach((id) => {
      const section = document.getElementById(id);
      if (!section) return;
      let hovered = false;
      section.addEventListener("mouseenter", () => { hovered = true; setCardTarget(section); });
      section.addEventListener("mouseleave", () => { hovered = false; cardTarget = null; });
      section.addEventListener("mousemove", (e) => {
        if (!hovered || !cardTarget || window.scrollY < SCROLL_THRESHOLD) return;
        cardTarget.y = e.clientY - SIZE / 2;
      });
    });
  }
</script>
