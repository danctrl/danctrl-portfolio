<div
  id="astronaut"
  class="pointer-events-none fixed z-30 hidden opacity-0 dark:opacity-100"
  aria-hidden="true"
>
  <div class="astronaut-glow"></div>
  <img
    src="/astronaut.svg"
    alt=""
    class="astronaut-img h-[210px] w-[210px]"
  />
</div>

<style>
  #astronaut {
    will-change: transform;
  }

  .astronaut-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300px;
    height: 300px;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, rgba(5, 150, 105, 0.15) 0%, transparent 70%);
    filter: blur(20px);
    pointer-events: none;
    z-index: -1;
    will-change: opacity, transform;
    transition: opacity 0.5s ease, transform 0.5s ease;
  }

  /* Glow pulses in sync with idle float */
  @keyframes glow-pulse {
    0%, 100% { opacity: 0.1; }
    50% { opacity: 0.2; }
  }

  #astronaut.idle .astronaut-glow {
    animation: glow-pulse 3s ease-in-out infinite;
  }

  /* Glow intensifies on scroll */
  #astronaut.scrolling .astronaut-glow {
    opacity: 0.25;
    transform: translate(-50%, -50%) scale(1.1);
  }

  /* Dash transition glow flicker */
  #astronaut.dashing .astronaut-glow {
    opacity: 0.3;
    transform: translate(-50%, -50%) scale(1.3);
    transition: opacity 0.15s ease, transform 0.15s ease;
  }

  .astronaut-img {
    position: relative;
    filter: drop-shadow(0 0 10px rgba(5, 150, 105, 0.25));
    will-change: transform;
    transition: filter 0.5s ease;
  }

  /* Hover: intensified glow on img */
  #astronaut.hovered .astronaut-img {
    filter: drop-shadow(0 0 30px rgba(5, 150, 105, 0.35));
  }
</style>

<script>
  const astronaut = document.getElementById("astronaut");
  const img = astronaut?.querySelector<HTMLElement>(".astronaut-img");
  const glow = astronaut?.querySelector<HTMLElement>(".astronaut-glow");

  if (astronaut && img && glow) {
    // ── Constants ──
    const BASE_SIZE = 210;
    const MIN_SIZE = 140;
    const MIN_VIEWPORT = 1280;   // don't show below this width
    const SCROLL_THRESHOLD = 100;
    const MIN_MARGIN = 160;      // minimum left margin (px) needed to show

    // Scroll-mode lerp (time-based smoothing factors, per second)
    const SMOOTH_POS = 4.5;    // position smoothing speed
    const SMOOTH_ROT = 3.5;    // rotation smoothing speed
    const SMOOTH_SCALE = 8.0;  // scale smoothing speed (snappy but smooth)
    const MAX_TILT = 12;
    const DRIFT_AMOUNT = 18;

    // Hero orbit
    const HERO_CYCLE = 24000;  // slower, more relaxed orbit
    const HERO_MAX_TILT = 8;
    const ORBIT_PADDING = 60;
    const HERO_SMOOTH = 3.0;  // how fast hero position catches up to orbit target

    // Mouse follow / hover
    const HOVER_RADIUS = 140;   // triggers when cursor is clearly near
    const MOUSE_ATTRACT = 0.04;
    const HOVER_SCALE = 1.2;

    // ── Dynamic sizing based on available margin ──
    let SIZE = BASE_SIZE;
    let isVisible = false;

    function getContentMarginLeft(): number {
      const content = document.querySelector("#hero .mx-auto") ||
                      document.querySelector("main .mx-auto") ||
                      document.querySelector(".mx-auto.max-w-5xl");
      if (!content) return window.innerWidth * 0.1;
      return content.getBoundingClientRect().left;
    }

    function updateVisibility() {
      const vw = window.innerWidth;

      if (vw < MIN_VIEWPORT) {
        if (isVisible) {
          astronaut.style.display = "none";
          isVisible = false;
        }
        return;
      }

      // Calculate available left margin
      const margin = getContentMarginLeft();
      const availableSpace = margin - 30; // 30px breathing room from content edge

      if (availableSpace < MIN_SIZE) {
        // Not enough space even for minimum size
        if (isVisible) {
          astronaut.style.display = "none";
          isVisible = false;
        }
        return;
      }

      // Scale astronaut to fit available space (capped at BASE_SIZE)
      SIZE = Math.min(BASE_SIZE, Math.max(MIN_SIZE, availableSpace - 20));

      // Update image size
      img.style.width = SIZE + "px";
      img.style.height = SIZE + "px";

      if (!isVisible) {
        astronaut.style.display = "block";
        isVisible = true;
      }
    }

    // ── State ──
    type Mode = "hero" | "scroll" | "dash-to-scroll";
    let mode: Mode = window.scrollY < SCROLL_THRESHOLD ? "hero" : "scroll";

    let currentX = 0;
    let currentY = 0;
    let currentRot = 0;

    // Scroll mode state
    let scrollTargetY = 0;
    let scrollBaseX = 0;
    let scrollXOffset = 0;
    let targetXOffset = 0;
    let lastScrollY = window.scrollY;
    let scrollVelocity = 0;       // raw per-frame delta
    let smoothScrollVel = 0;      // exponentially smoothed velocity for visuals
    let idleTimer: ReturnType<typeof setTimeout> | null = null;
    let isIdle = false;
    let idleTime = 0;           // accumulated idle time for float animation
    const IDLE_FLOAT_AMP = 8;   // pixels of vertical bob
    const IDLE_FLOAT_ROT = 3;   // degrees of idle tilt
    const IDLE_FLOAT_SPEED = 2.1; // cycles per second (matches old 3s period)

    // Mouse state
    let mouseX = -9999;
    let mouseY = -9999;
    let isHovered = false;
    let currentScale = 1;

    // Card hover attraction
    let cardTarget: { x: number; y: number } | null = null;

    // Hero orbit state
    let heroStartTime = performance.now();
    let heroOrbitTime = 0; // virtual time that advances slower when hovered
    let lastTickTime = performance.now();
    const HOVER_SPEED = 0.2; // 20% of normal speed when hovered

    // Transition state
    let transStartTime = 0;
    let transStartX = 0;
    let transStartY = 0;
    let transStartRot = 0;
    let transDuration = 0;

    // ── Catmull-Rom spline interpolation ──
    function catmullRom(p0: number, p1: number, p2: number, p3: number, t: number): number {
      const t2 = t * t;
      const t3 = t2 * t;
      return 0.5 * (
        (2 * p1) +
        (-p0 + p2) * t +
        (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
        (-p0 + 3 * p1 - 3 * p2 + p3) * t3
      );
    }

    // ── Compute and cache waypoints around the hero content ──
    let cachedWaypoints: { x: number; y: number }[] = [];
    let waypointsDirty = true;

    function computeWaypoints(): { x: number; y: number }[] {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const nav = document.querySelector("nav");
      const hero = document.getElementById("hero");
      const contentDiv = hero?.querySelector(".mx-auto");

      const navBottom = nav ? nav.getBoundingClientRect().bottom + 15 : 80;

      if (!contentDiv) {
        return [
          { x: vw * 0.7, y: navBottom + 20 },
          { x: vw - SIZE - 20, y: vh * 0.35 },
          { x: vw * 0.6, y: vh * 0.75 },
          { x: 20, y: vh * 0.6 },
          { x: 20, y: navBottom + 20 },
          { x: vw * 0.35, y: navBottom + 20 },
        ];
      }

      const cr = contentDiv.getBoundingClientRect();
      const pad = ORBIT_PADDING;
      const half = SIZE / 2;

      const safeLeft = Math.max(10, cr.left - SIZE - pad * 0.3);
      const safeRight = Math.min(cr.right + pad, vw - SIZE - 10);
      const safeTop = Math.max(navBottom + 10, cr.top - SIZE - pad);
      const safeBottom = Math.min(cr.bottom + pad, vh - SIZE - 10);

      return [
        { x: Math.min(cr.left + cr.width * 0.4 - half, safeRight), y: safeTop },
        { x: safeRight, y: safeTop + 20 },
        { x: safeRight, y: cr.top + cr.height * 0.25 },
        { x: safeRight, y: cr.top + cr.height * 0.7 },
        { x: Math.min(cr.left + cr.width * 0.7, safeRight), y: safeBottom },
        { x: Math.max(cr.left + cr.width * 0.2 - half, safeLeft), y: safeBottom },
        { x: safeLeft, y: safeBottom - 20 },
        { x: safeLeft, y: cr.top + cr.height * 0.4 },
      ];
    }

    function getOrbitWaypoints(): { x: number; y: number }[] {
      if (waypointsDirty) {
        cachedWaypoints = computeWaypoints();
        waypointsDirty = false;
      }
      return cachedWaypoints;
    }

    // Invalidate on resize (not every frame)
    window.addEventListener("resize", () => { waypointsDirty = true; arcTableDirty = true; });

    // ── Arc-length table for uniform-speed orbit ──
    // Maps normalized distance [0..1] → { segment, t } so the astronaut
    // travels at constant visual speed regardless of waypoint spacing.
    let arcTable: { totalLen: number; cumLengths: number[] }  = { totalLen: 0, cumLengths: [] };
    let arcTableDirty = true;

    function rebuildArcTable() {
      const wp = getOrbitWaypoints();
      const n = wp.length;
      const SAMPLES_PER_SEG = 16;
      const cumLengths: number[] = [0];
      let total = 0;

      for (let seg = 0; seg < n; seg++) {
        const p0 = wp[(seg - 1 + n) % n];
        const p1 = wp[seg];
        const p2 = wp[(seg + 1) % n];
        const p3 = wp[(seg + 2) % n];
        let prevX = catmullRom(p0.x, p1.x, p2.x, p3.x, 0);
        let prevY = catmullRom(p0.y, p1.y, p2.y, p3.y, 0);

        for (let i = 1; i <= SAMPLES_PER_SEG; i++) {
          const st = i / SAMPLES_PER_SEG;
          const cx = catmullRom(p0.x, p1.x, p2.x, p3.x, st);
          const cy = catmullRom(p0.y, p1.y, p2.y, p3.y, st);
          total += Math.sqrt((cx - prevX) ** 2 + (cy - prevY) ** 2);
          prevX = cx;
          prevY = cy;
        }
        cumLengths.push(total);
      }

      arcTable = { totalLen: total, cumLengths };
      arcTableDirty = false;
    }

    // Convert normalized distance [0..1] → segment + local t
    function arcToParam(d: number): { segment: number; t: number } {
      if (arcTableDirty) rebuildArcTable();
      const wp = getOrbitWaypoints();
      const n = wp.length;
      const targetLen = d * arcTable.totalLen;

      // Find which segment this distance falls in
      let seg = 0;
      for (let i = 1; i <= n; i++) {
        if (arcTable.cumLengths[i] >= targetLen) {
          seg = i - 1;
          break;
        }
        if (i === n) seg = n - 1;
      }

      const segStart = arcTable.cumLengths[seg];
      const segEnd = arcTable.cumLengths[seg + 1];
      const segLen = segEnd - segStart;
      const t = segLen > 0 ? (targetLen - segStart) / segLen : 0;

      return { segment: seg, t };
    }

    // ── Get hero orbit position from virtual orbit time ──
    function getHeroPos(_time: number): { x: number; y: number; rot: number } {
      const waypoints = getOrbitWaypoints();
      const n = waypoints.length;

      // Uniform-speed progress via arc-length parameterization
      const progress = ((heroOrbitTime % HERO_CYCLE) + HERO_CYCLE) % HERO_CYCLE / HERO_CYCLE;
      const { segment, t } = arcToParam(progress);

      const p0 = waypoints[(segment - 1 + n) % n];
      const p1 = waypoints[segment];
      const p2 = waypoints[(segment + 1) % n];
      const p3 = waypoints[(segment + 2) % n];

      const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
      const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);

      // Smooth tangent via central difference
      const epsilon = 0.005;
      const tNext = Math.min(t + epsilon, 0.999);
      const tPrev = Math.max(t - epsilon, 0.001);
      const dx = catmullRom(p0.x, p1.x, p2.x, p3.x, tNext) - catmullRom(p0.x, p1.x, p2.x, p3.x, tPrev);
      const dy = catmullRom(p0.y, p1.y, p2.y, p3.y, tNext) - catmullRom(p0.y, p1.y, p2.y, p3.y, tPrev);
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);
      const tilt = Math.max(-HERO_MAX_TILT, Math.min(HERO_MAX_TILT, angle * 0.1));

      return { x, y, rot: tilt };
    }

    // ── Find nearest orbit phase to a given position ──
    // Returns the heroOrbitTime value that produces the closest orbit position
    function findNearestOrbitPhase(px: number, py: number): number {
      const samples = 64;
      let bestDist = Infinity;
      let bestPhase = 0;
      const savedOrbitTime = heroOrbitTime;

      for (let i = 0; i < samples; i++) {
        heroOrbitTime = (i / samples) * HERO_CYCLE;
        const pos = getHeroPos(0); // _time param is ignored, uses heroOrbitTime
        const dx = pos.x - px;
        const dy = pos.y - py;
        const dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          bestPhase = heroOrbitTime;
        }
      }

      heroOrbitTime = savedOrbitTime;
      return bestPhase;
    }

    // ── Scroll mode helpers ──
    function getScrollTargetY() {
      const scrollY = window.scrollY;
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      if (maxScroll <= 0) return window.innerHeight * 0.2;
      const ratio = scrollY / maxScroll;
      return window.innerHeight * (0.1 + ratio * 0.7);
    }

    function getScrollBaseX() {
      // Center astronaut in the left margin, never overlapping content
      const margin = getContentMarginLeft();
      const centered = Math.max(10, (margin - SIZE) / 2);
      return centered;
    }

    function enterIdle() {
      if (!isIdle) {
        isIdle = true;
      }
    }

    function exitIdle() {
      if (isIdle) {
        isIdle = false;
      }
    }

    // ── Transition easing ──
    function easeOutCubic(t: number) {
      return 1 - Math.pow(1 - t, 3);
    }

    function dashEase(t: number) {
      return 1 - Math.pow(1 - t, 4);
    }

    // ── Start transitions ──
    function startDashToScroll() {
      mode = "dash-to-scroll";
      transStartTime = performance.now();
      transStartX = currentX;
      transStartY = currentY;
      transStartRot = currentRot;
      transDuration = 400;

      astronaut.classList.remove("idle", "scrolling");
      astronaut.classList.add("dashing");
      isIdle = false;

      setTimeout(() => {
        astronaut.classList.remove("dashing");
      }, 300);
    }

    // Glide-to-hero: switch to hero mode, converge smoothly with velocity cap
    let heroConverging = false;
    const HERO_MAX_SPEED = 6;  // max pixels per frame during convergence (smooth glide)

    function startGlideToHero() {
      mode = "hero";
      heroConverging = true;

      astronaut.classList.remove("idle", "scrolling");
      isIdle = false;

      // Don't compute waypoints yet — scroll is still settling.
      // Hero tick will recompute each frame during convergence.
    }

    // ── Time-based exponential smoothing ──
    // Returns a lerp factor for a given speed and delta time (frame-rate independent)
    function damp(smoothing: number, deltaS: number): number {
      return 1 - Math.exp(-smoothing * deltaS);
    }

    // ── Apply position (GPU-accelerated via translate3d) ──
    // Idle float is computed in JS so it never fights the scale transform.
    let idleFloatY = 0;
    let idleFloatRot = 0;

    function applyPosition(x: number, y: number, rot: number) {
      currentX = x;
      currentY = y;
      currentRot = rot;
      astronaut.style.transform = `translate3d(${x.toFixed(1)}px, ${(y + idleFloatY).toFixed(1)}px, 0)`;
      img.style.transform = `rotate(${(rot + idleFloatRot).toFixed(1)}deg) scale(${currentScale.toFixed(3)})`;
    }

    // ── Mouse proximity check ──
    function updateMouseHover(finalX: number, finalY: number): { x: number; y: number } {
      const centerX = finalX + SIZE / 2;
      const centerY = finalY + SIZE / 2;
      const dx = mouseX - centerX;
      const dy = mouseY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      const wasHovered = isHovered;
      isHovered = dist < HOVER_RADIUS;

      if (isHovered !== wasHovered) {
        if (isHovered) {
          astronaut.classList.add("hovered");
          glow.style.opacity = "0.25";
          glow.style.transform = "translate(-50%, -50%) scale(1.1)";
        } else {
          astronaut.classList.remove("hovered");
          glow.style.opacity = "";
          glow.style.transform = "";
        }
      }

      if (isHovered) {
        const attractX = finalX + (mouseX - centerX) * MOUSE_ATTRACT;
        const attractY = finalY + (mouseY - centerY) * MOUSE_ATTRACT;
        return { x: attractX, y: attractY };
      }

      return { x: finalX, y: finalY };
    }

    // ── Main loop ──
    function tick(now: number) {
      if (!isVisible) {
        requestAnimationFrame(tick);
        return;
      }

      // Time delta in seconds (capped to avoid jumps after tab switch)
      const dt = Math.min((now - lastTickTime) / 1000, 0.1);
      lastTickTime = now;

      const newScrollY = window.scrollY;
      const scrollDelta = newScrollY - lastScrollY;
      scrollVelocity = scrollDelta;
      // Exponentially smooth scroll velocity for visuals (rotation, scale)
      smoothScrollVel += (scrollVelocity - smoothScrollVel) * damp(8, dt);
      lastScrollY = newScrollY;

      // Mode switching
      if (mode === "hero" && newScrollY >= SCROLL_THRESHOLD) {
        startDashToScroll();
      } else if (mode === "scroll" && newScrollY < SCROLL_THRESHOLD) {
        startGlideToHero();
      }

      // Smooth scale (hover > transition > fast scroll > normal)
      const SCROLL_SCALE = 1.15;
      const SCROLL_SCALE_THRESHOLD = 15;
      const absSmooth = Math.abs(smoothScrollVel);
      const isTransitioning = mode === "dash-to-scroll" || heroConverging;
      const targetScale = isHovered ? HOVER_SCALE
        : isTransitioning ? SCROLL_SCALE
        : absSmooth > SCROLL_SCALE_THRESHOLD ? SCROLL_SCALE
        : 1;
      currentScale += (targetScale - currentScale) * damp(SMOOTH_SCALE, dt);

      // Idle float (JS-driven so it never fights the scale transform)
      if (isIdle) {
        idleTime += dt;
        const phase = idleTime * IDLE_FLOAT_SPEED * Math.PI * 2;
        const targetFloatY = Math.sin(phase) * IDLE_FLOAT_AMP;
        const targetFloatRot = Math.sin(phase) * IDLE_FLOAT_ROT;
        idleFloatY += (targetFloatY - idleFloatY) * damp(6, dt);
        idleFloatRot += (targetFloatRot - idleFloatRot) * damp(6, dt);
      } else {
        // Smoothly ease float offset back to zero
        idleFloatY += (0 - idleFloatY) * damp(6, dt);
        idleFloatRot += (0 - idleFloatRot) * damp(6, dt);
      }

      // Advance virtual orbit time (slows down when hovered)
      if (mode === "hero") {
        const speed = isHovered ? HOVER_SPEED : 1;
        heroOrbitTime += dt * 1000 * speed;
      }

      switch (mode) {
        case "hero": {
          // During convergence, recompute waypoints each frame as scroll settles
          if (heroConverging) {
            waypointsDirty = true;
            arcTableDirty = true;
            heroOrbitTime = findNearestOrbitPhase(currentX, currentY);
          }

          const pos = getHeroPos(now);
          const hf = damp(HERO_SMOOTH, dt);
          let dx = (pos.x - currentX) * hf;
          let dy = (pos.y - currentY) * hf;

          // Cap velocity during convergence for buttery-smooth glide
          if (heroConverging) {
            const moveDist = Math.sqrt(dx * dx + dy * dy);
            if (moveDist > HERO_MAX_SPEED) {
              const cap = HERO_MAX_SPEED / moveDist;
              dx *= cap;
              dy *= cap;
            }
            // End convergence once close to the orbit
            const dist = Math.sqrt((pos.x - currentX) ** 2 + (pos.y - currentY) ** 2);
            if (dist < 20) {
              heroConverging = false;
              // Cache the final waypoints now that scroll has settled
              waypointsDirty = true;
              arcTableDirty = true;
            }
          }

          let hx = currentX + dx;
          let hy = currentY + dy;
          const hr = currentRot + (pos.rot - currentRot) * hf;
          const m = updateMouseHover(hx, hy);
          applyPosition(m.x, m.y, hr);
          break;
        }

        case "dash-to-scroll": {
          const elapsed = now - transStartTime;
          const progress = Math.min(elapsed / transDuration, 1);
          const ease = dashEase(progress);

          const targetX = getScrollBaseX();
          const targetY = getScrollTargetY();

          let x = transStartX + (targetX - transStartX) * ease;
          let y = transStartY + (targetY - transStartY) * ease;

          // Smooth sine rotation kick during dash
          const rotKick = 12 * Math.sin(progress * Math.PI);

          const m = updateMouseHover(x, y);
          applyPosition(m.x, m.y, rotKick);

          if (progress >= 1) {
            mode = "scroll";
            enterIdle();
          }
          break;
        }


        case "scroll": {
          scrollTargetY = getScrollTargetY();
          scrollBaseX = getScrollBaseX();

          // Smooth drift offset based on smoothed velocity
          targetXOffset = -Math.min(Math.abs(smoothScrollVel) * 0.7, DRIFT_AMOUNT) * Math.sign(smoothScrollVel || 1);
          scrollXOffset += (targetXOffset - scrollXOffset) * damp(6, dt);

          let targetX: number;
          let targetY: number;
          let posSpeed: number;

          if (cardTarget) {
            targetX = cardTarget.x;
            targetY = cardTarget.y;
            posSpeed = SMOOTH_POS * 0.7; // slightly slower for graceful card approach
            exitIdle();
          } else {
            targetX = scrollBaseX + scrollXOffset;
            targetY = scrollTargetY;
            posSpeed = SMOOTH_POS;
          }

          const posFactor = damp(posSpeed, dt);
          let x = currentX + (targetX - currentX) * posFactor;
          let y = currentY + (targetY - currentY) * posFactor;

          // Tilt: use smoothed velocity for natural, non-jerky rotation
          let targetRot: number;
          if (cardTarget) {
            const dx = targetX - currentX;
            const dy = targetY - currentY;
            const travelAngle = Math.atan2(dy, dx) * (180 / Math.PI);
            const dist = Math.sqrt(dx * dx + dy * dy);
            targetRot = dist > 5 ? Math.max(-MAX_TILT, Math.min(MAX_TILT, travelAngle * 0.12)) : 0;
          } else {
            targetRot = Math.max(-MAX_TILT, Math.min(MAX_TILT, smoothScrollVel * 1.2));
          }
          const rot = currentRot + (targetRot - currentRot) * damp(SMOOTH_ROT, dt);

          const m = updateMouseHover(x, y);
          x = m.x;
          y = m.y;

          applyPosition(x, y, rot);

          if (Math.abs(scrollVelocity) > 0.5) {
            exitIdle();
            astronaut.classList.add("scrolling");
            if (idleTimer) clearTimeout(idleTimer);
            idleTimer = setTimeout(() => {
              if (!cardTarget) enterIdle();
              astronaut.classList.remove("scrolling");
            }, 800);
          }

          // Re-enter idle when returning from card and close to scroll position
          if (!cardTarget && !isIdle && Math.abs(scrollVelocity) < 0.5) {
            const distToHome = Math.abs(currentX - scrollBaseX) + Math.abs(currentY - scrollTargetY);
            if (distToHome < 10) {
              enterIdle();
            }
          }
          break;
        }
      }

      // ── Timeline dot proximity glow ──
      updateTimelineDots();

      requestAnimationFrame(tick);
    }

    // ── Timeline dots: only one active at a time, card hover takes priority ──
    const timelineEntries = document.querySelectorAll<HTMLElement>(".timeline-entry");
    const SECTION_EARLY = 20; // activate 20px before entering section
    let activeDot: HTMLElement | null = null;
    let cardHoveredDot: HTMLElement | null = null;

    function updateTimelineDots() {
      if (!isVisible || mode === "hero") {
        if (activeDot) {
          activeDot.classList.remove("astronaut-near");
          activeDot = null;
        }
        return;
      }

      // Card hover takes priority
      let bestDot: HTMLElement | null = cardHoveredDot;

      // If no card is hovered, find the entry whose section the astronaut is nearest to
      if (!bestDot) {
        const astroCenterY = currentY + SIZE / 2;
        let bestDist = Infinity;

        timelineEntries.forEach((entry) => {
          const rect = entry.getBoundingClientRect();
          const top = rect.top - SECTION_EARLY;
          const bottom = rect.bottom + SECTION_EARLY;

          // Distance: 0 if inside, otherwise distance to nearest edge
          let dist: number;
          if (astroCenterY >= top && astroCenterY <= bottom) {
            dist = 0;
          } else {
            dist = Math.min(Math.abs(astroCenterY - top), Math.abs(astroCenterY - bottom));
          }

          if (dist < bestDist && dist === 0) {
            bestDist = dist;
            bestDot = entry.querySelector<HTMLElement>(".timeline-dot");
          }
        });
      }

      // Switch active dot (only one at a time)
      if (bestDot !== activeDot) {
        if (activeDot) activeDot.classList.remove("astronaut-near");
        if (bestDot) bestDot.classList.add("astronaut-near");
        activeDot = bestDot;
      }
    }

    // ── Initialize ──
    updateVisibility();

    if (isVisible) {
      if (mode === "hero") {
        heroOrbitTime = Math.random() * HERO_CYCLE; // randomize start position
        const pos = getHeroPos(performance.now());
        applyPosition(pos.x, pos.y, pos.rot);
      } else {
        scrollBaseX = getScrollBaseX();
        currentX = scrollBaseX;
        currentY = getScrollTargetY();
        applyPosition(currentX, currentY, 0);
        enterIdle();
      }
    }

    requestAnimationFrame(tick);

    // Nav click boost
    document.querySelectorAll('a[href^="#"]').forEach((link) => {
      link.addEventListener("click", () => {
        astronaut.classList.add("boost");
        setTimeout(() => astronaut.classList.remove("boost"), 200);
      });
    });

    // Recalculate on resize
    window.addEventListener("resize", updateVisibility);

    // Track mouse globally
    document.addEventListener("mousemove", (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    document.addEventListener("mouseleave", () => {
      mouseX = -9999;
      mouseY = -9999;
    });

    // ── Card/section hover: astronaut flies to hovered element ──
    function setCardTarget(el: HTMLElement) {
      if (mode !== "scroll" && mode !== "dash-to-scroll") return;
      const rect = el.getBoundingClientRect();
      cardTarget = {
        x: Math.max(10, rect.left - SIZE - 20),
        y: rect.top + rect.height / 2 - SIZE / 2,
      };
      if (cardTarget.x < 10) {
        cardTarget.x = rect.left + 20;
        cardTarget.y = Math.max(10, rect.top - SIZE - 15);
      }
    }

    // Section cards (experience, education, projects)
    document.querySelectorAll<HTMLElement>(".section-card:not(.section-card--static)").forEach((card) => {
      card.addEventListener("mouseenter", () => {
        setCardTarget(card);
        const entry = card.closest(".timeline-entry");
        cardHoveredDot = entry?.querySelector<HTMLElement>(".timeline-dot") || null;
      });

      card.addEventListener("mouseleave", () => {
        cardTarget = null;
        cardHoveredDot = null;
      });
    });

    // Skills section: astronaut follows cursor Y level
    let skillsHovered = false;
    const skillsSection = document.getElementById("skills");
    if (skillsSection) {
      skillsSection.addEventListener("mouseenter", () => {
        skillsHovered = true;
        setCardTarget(skillsSection);
      });
      skillsSection.addEventListener("mouseleave", () => {
        skillsHovered = false;
        cardTarget = null;
      });
      skillsSection.addEventListener("mousemove", (e) => {
        if (!skillsHovered || !cardTarget) return;
        if (mode !== "scroll" && mode !== "dash-to-scroll") return;
        cardTarget.y = e.clientY - SIZE / 2;
      });
    }

    // Contact section: astronaut follows cursor Y level
    let contactHovered = false;
    const contactSection = document.getElementById("contact");
    if (contactSection) {
      contactSection.addEventListener("mouseenter", () => {
        contactHovered = true;
        setCardTarget(contactSection);
      });
      contactSection.addEventListener("mouseleave", () => {
        contactHovered = false;
        cardTarget = null;
      });
      contactSection.addEventListener("mousemove", (e) => {
        if (!contactHovered || !cardTarget) return;
        if (mode !== "scroll" && mode !== "dash-to-scroll") return;
        cardTarget.y = e.clientY - SIZE / 2;
      });
    }
  }
</script>
