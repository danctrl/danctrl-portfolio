---
const titles = [
    "DevOps Engineer",
    "System Administrator",
    "Cybersecurity Enthusiast",
    "AI Explorer",
];
---

<section id="hero" class="relative flex min-h-screen items-center overflow-hidden pt-16">
    <!-- Gradient background -->
    <div class="hero-gradient absolute inset-0 -z-10" aria-hidden="true"></div>

    <!-- Floating geometric shapes (interactive) -->
    <div
        id="shapes-container"
        class="pointer-events-none absolute inset-0 z-10 overflow-hidden"
        aria-hidden="true"
    >
        <!-- Circle — upper-left, near status pill -->
        <div
            class="floating-shape draggable-shape pointer-events-auto absolute top-[18%] left-[12%] h-[60px] w-[60px] cursor-grab rounded-full border border-emerald-600/10 dark:border-emerald-500/20"
            style="animation-duration: 10s;"
        >
        </div>
        <!-- Triangle — lower-right, near buttons -->
        <svg
            class="floating-shape draggable-shape pointer-events-auto absolute top-[68%] right-[15%] h-[50px] w-[50px] cursor-grab text-emerald-600/8 dark:text-emerald-500/15"
            style="animation-duration: 8s; animation-delay: -3s;"
            viewBox="0 0 50 50"
            fill="currentColor"
            ><polygon points="25,5 45,45 5,45"></polygon></svg
        >
        <!-- Hexagon — right side, headline level -->
        <svg
            class="floating-shape draggable-shape pointer-events-auto absolute top-[28%] right-[8%] h-[40px] w-[40px] cursor-grab text-emerald-600/6 dark:text-emerald-500/10"
            style="animation-duration: 12s; animation-delay: -5s;"
            viewBox="0 0 100 100"
            fill="currentColor"
            ><polygon points="50,3 97,25 97,75 50,97 3,75 3,25"></polygon></svg
        >
        <!-- Small circle — below content, left-of-center -->
        <div
            class="floating-shape draggable-shape pointer-events-auto absolute bottom-[15%] left-[25%] h-[30px] w-[30px] cursor-grab rounded-full bg-emerald-600/6 dark:bg-emerald-500/10"
            style="animation-duration: 13s; animation-delay: -4s;"
        >
        </div>
        <!-- Diamond — left margin, subtitle level -->
        <svg
            class="floating-shape draggable-shape pointer-events-auto absolute top-[48%] left-[7%] h-[35px] w-[35px] cursor-grab text-emerald-600/8 dark:text-emerald-500/12"
            style="animation-duration: 11s; animation-delay: -2s;"
            viewBox="0 0 50 50"
            fill="currentColor"
            ><polygon points="25,2 48,25 25,48 2,25"></polygon></svg
        >
        <!-- Square (rotated) — upper-right area -->
        <div
            class="floating-shape draggable-shape pointer-events-auto absolute top-[40%] right-[20%] h-[25px] w-[25px] rotate-45 cursor-grab border border-emerald-600/10 dark:border-emerald-500/15"
            style="animation-duration: 14s; animation-delay: -7s;"
        >
        </div>
    </div>

    <div class="mx-auto max-w-5xl px-6 py-24 text-center md:text-left">
        <!-- Status indicator -->
        <div
            class="glass mb-8 inline-flex items-center gap-2 rounded-full px-4 py-1.5 text-sm text-gray-600 dark:text-gray-400"
        >
            <span class="relative flex h-2 w-2">
                <span
                    class="absolute inline-flex h-full w-full animate-ping rounded-full bg-emerald-400 opacity-75"
                ></span>
                <span
                    class="relative inline-flex h-2 w-2 rounded-full bg-emerald-500"
                ></span>
            </span>
            Open for opportunities
        </div>

        <!-- Headline -->
        <h1
            class="mb-6 font-mono text-2xl font-bold leading-tight tracking-tight text-[#1a1a1a] sm:text-3xl md:text-4xl lg:text-5xl dark:text-white"
        >
            Documenting the journey<br />of building infrastructure
        </h1>

        <!-- Typing subtitle -->
        <div
            class="mb-4 flex h-8 items-center justify-center text-base text-gray-500 sm:text-lg md:text-xl md:justify-start dark:text-gray-400"
        >
            <span id="typing-text" aria-label={titles.join(", ")}></span><span
                class="typing-cursor text-emerald-500">|</span
            >
        </div>

        <!-- Description -->
        <p
            class="mx-auto mb-10 max-w-2xl text-sm text-gray-500 sm:text-base lg:text-lg md:mx-0 dark:text-gray-400"
        >
            DevOps enthusiast based in Berlin, bridging technical systems with
            business understanding.
        </p>

        <!-- CTAs -->
        <div
            class="flex flex-col items-center justify-center gap-4 min-[400px]:flex-row md:justify-start"
        >
            <a
                href="#about"
                class="btn-primary inline-flex h-[40px] items-center gap-2 rounded-lg px-4 text-sm sm:h-[44px] sm:px-6"
            >
                About me
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3" />
                </svg>
            </a>
            <a
                href="#projects"
                class="btn-secondary inline-flex h-[40px] items-center rounded-lg px-4 text-sm font-semibold sm:h-[44px] sm:px-6"
            >
                Browse Projects
            </a>
        </div>
    </div>
</section>

<script define:vars={{ titles }}>
    const el = document.getElementById("typing-text");
    if (el) {
        let titleIndex = 0;
        let charIndex = 0;
        let deleting = false;
        const typeSpeed = 80;
        const deleteSpeed = 40;
        const pauseAfterType = 2000;
        const pauseAfterDelete = 500;

        function tick() {
            const current = titles[titleIndex];
            if (!deleting) {
                el.textContent = current.slice(0, charIndex + 1);
                charIndex++;
                if (charIndex === current.length) {
                    deleting = true;
                    setTimeout(tick, pauseAfterType);
                    return;
                }
                setTimeout(tick, typeSpeed);
            } else {
                el.textContent = current.slice(0, charIndex - 1);
                charIndex--;
                if (charIndex === 0) {
                    deleting = false;
                    titleIndex = (titleIndex + 1) % titles.length;
                    setTimeout(tick, pauseAfterDelete);
                    return;
                }
                setTimeout(tick, deleteSpeed);
            }
        }
        tick();
    }
</script>

<script>
    // ── Content avoidance for floating shapes ──
    // Nudge shapes away from interactive elements (buttons, headlines, status pill)
    function avoidContent() {
        const container = document.getElementById("shapes-container");
        if (!container) return;
        const cRect = container.getBoundingClientRect();

        // Collect rects of all interactive/content elements in hero
        const selectors = [
            "#hero h1",
            "#hero .btn-primary",
            "#hero .btn-secondary",
            "#hero .glass",         // status pill
            "#typing-text",
            "#hero p",
        ];
        const contentRects: DOMRect[] = [];
        const PADDING = 50; // breathing room around content
        selectors.forEach((sel) => {
            document.querySelectorAll(sel).forEach((el) => {
                const r = el.getBoundingClientRect();
                contentRects.push(new DOMRect(
                    r.left - PADDING,
                    r.top - PADDING,
                    r.width + PADDING * 2,
                    r.height + PADDING * 2,
                ));
            });
        });

        // Check each shape and nudge if overlapping
        container.querySelectorAll<HTMLElement>(".draggable-shape").forEach((shape) => {
            // Skip shapes that have been dragged (have inline left set)
            if (shape.style.left && shape.style.left !== "auto") return;

            const sr = shape.getBoundingClientRect();
            const shapeCX = sr.left + sr.width / 2;
            const shapeCY = sr.top + sr.height / 2;

            for (const cr of contentRects) {
                if (
                    sr.right > cr.left &&
                    sr.left < cr.right &&
                    sr.bottom > cr.top &&
                    sr.top < cr.bottom
                ) {
                    // Overlapping — push to nearest edge
                    const pushLeft = cr.left - sr.right;
                    const pushRight = cr.right - sr.left;
                    const pushUp = cr.top - sr.bottom;
                    const pushDown = cr.bottom - sr.top;

                    // Pick smallest push direction
                    const pushes = [
                        { dx: pushLeft, dy: 0, dist: Math.abs(pushLeft) },
                        { dx: pushRight, dy: 0, dist: Math.abs(pushRight) },
                        { dx: 0, dy: pushUp, dist: Math.abs(pushUp) },
                        { dx: 0, dy: pushDown, dist: Math.abs(pushDown) },
                    ];
                    pushes.sort((a, b) => a.dist - b.dist);
                    const best = pushes[0];

                    // Convert to left/top positioning and apply
                    const currentLeft = sr.left - cRect.left;
                    const currentTop = sr.top - cRect.top;
                    shape.style.left = (currentLeft + best.dx) + "px";
                    shape.style.top = (currentTop + best.dy) + "px";
                    shape.style.right = "auto";
                    shape.style.bottom = "auto";
                    break;
                }
            }
        });
    }

    // Run after layout settles
    requestAnimationFrame(() => requestAnimationFrame(avoidContent));
    window.addEventListener("resize", avoidContent);

    // Interactive drag & throw for floating shapes
    document.querySelectorAll<HTMLElement>(".draggable-shape").forEach((shape) => {
        let isDragging = false;
        let startMouseX = 0;
        let startMouseY = 0;
        let startLeft = 0;
        let startTop = 0;
        let velX = 0;
        let velY = 0;
        let lastX = 0;
        let lastY = 0;
        let lastTime = 0;
        let animFrame = 0;

        // Convert initial positioning (right/bottom/%) to left/top px on first interaction
        function ensureLeftTop() {
            const rect = shape.getBoundingClientRect();
            const container = shape.parentElement!;
            const cRect = container.getBoundingClientRect();
            shape.style.left = (rect.left - cRect.left) + "px";
            shape.style.top = (rect.top - cRect.top) + "px";
            shape.style.right = "auto";
            shape.style.bottom = "auto";
        }

        shape.addEventListener("mousedown", (e: MouseEvent) => {
            isDragging = true;
            shape.style.animation = "none";
            shape.style.cursor = "grabbing";
            ensureLeftTop();
            startLeft = parseFloat(shape.style.left);
            startTop = parseFloat(shape.style.top);
            startMouseX = e.clientX;
            startMouseY = e.clientY;
            lastX = e.clientX;
            lastY = e.clientY;
            lastTime = Date.now();
            velX = 0;
            velY = 0;
            cancelAnimationFrame(animFrame);
            e.preventDefault();
        });

        document.addEventListener("mousemove", (e: MouseEvent) => {
            if (!isDragging) return;
            const x = startLeft + (e.clientX - startMouseX);
            const y = startTop + (e.clientY - startMouseY);
            shape.style.left = x + "px";
            shape.style.top = y + "px";

            const now = Date.now();
            const dt = now - lastTime || 1;
            velX = (e.clientX - lastX) / dt * 16;
            velY = (e.clientY - lastY) / dt * 16;
            lastX = e.clientX;
            lastY = e.clientY;
            lastTime = now;
        });

        document.addEventListener("mouseup", () => {
            if (!isDragging) return;
            isDragging = false;
            shape.style.cursor = "grab";

            const friction = 0.95;
            function drift() {
                if (Math.abs(velX) < 0.1 && Math.abs(velY) < 0.1) {
                    // Resume floating from current position
                    shape.style.animation = "";
                    return;
                }
                const currentLeft = parseFloat(shape.style.left) || 0;
                const currentTop = parseFloat(shape.style.top) || 0;
                shape.style.left = (currentLeft + velX) + "px";
                shape.style.top = (currentTop + velY) + "px";
                velX *= friction;
                velY *= friction;
                animFrame = requestAnimationFrame(drift);
            }
            drift();
        });
    });
</script>
